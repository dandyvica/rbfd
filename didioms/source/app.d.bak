import std.stdio;
import std.container.array;
import std.conv;
import std.algorithm;
import std.string;
import std.process;
import std.range;
import std.typecons;


class Field {

	string name;
	ulong length;
	string value;

	this(string n) {
		name = n;
	}

	override string toString() {
		return "name=%s, value=%s".format(name, value);
	}
}




class FieldContainer(T) {
	alias TNAME  = typeof(T.name);
	alias TVALUE = typeof(T.value);

	T[] list;
	Tuple!(T, ulong)[][TNAME] map;
	//ulong[][TNAME] index;

	@property ulong size() { return list.length; }
	@property ulong length() {
		return std.algorithm.iteration.sum(list.map!(e => e.length));
	}

	string getMembersData(string memberName) {
		auto s = "return array(T.map!(e => e." ~ memberName ~ "));";
		return (s);
	}

	//----------------------------------------------------------------------------
	// add methods
	//----------------------------------------------------------------------------

	void opOpAssign(string op)(T element) if (op == "~")
	{
		list ~= element;
		map[element.name] ~= element;
		index[element.name] ~= list.length-1;
	}

	//----------------------------------------------------------------------------
	// index methods
	//----------------------------------------------------------------------------

	T opIndex(size_t i) { return list[i]; }
	T[] opIndex(TNAME name) { return map[name]; }
	T[] opSlice(size_t i, size_t j) { return list[i..j]; }

	///
/*
	size_t[] index(string name) {

	}*/

	/// remove a single element at index i
	void remove(size_t i) {
		/// first get its name
		TNAME name = this[i].name;
		list.remove(i);
	}

	//----------------------------------------------------------------------------
	// remove methods
	//----------------------------------------------------------------------------

	/// remove elements matching name (as the same name may appear several times)
	void remove(TNAME name) {
		list = list.remove!(f => f.name == name);

		// remove corresponding key
		map.remove(name);
	}

	// remove all elements in the list
	void remove(TNAME[] name) { name.each!(e => this.remove(e)); }

	// keep only but all elements of the list
	void keep(TNAME[] name) {
		//auto notPresent = list.find!("a != b")(name[0]);
		list = array(list.filter!(e => name.canFind(e.name)));
		auto keys = map.keys.filter!(e => !name.canFind(e));
		keys.each!(e => map.remove(e));
	}

	//----------------------------------------------------------------------------
	// reduce methods
	//----------------------------------------------------------------------------

	// sum of elements converted to type U
	U sum(U)(TNAME name) {
		return list.filter!(e => e.name == name).map!(e => to!U(e.value)).sum();
	}


	void inspect() {
		//list.each!(e => writeln(e));
	writefln("list   => %s", list);
	writefln("map    => %s", map);
	writefln("index  => %s", index);
	}

}

/*
class FieldContainerRange(T) {
	FieldContainer!T fields;

	this(FieldContainer!T f) { fields = f; }

	@property bool empty() const { return fields.length == 0; }
	@property ref FieldContainer!T front() { return fields[0]; }
	void popFront() { fields.popFront(); }
}

FieldContainerRange!T myRange(T)(T elem) {
	return new FieldContainerRange!T(elem);
}
*/



void main(string[] argv)
{
	auto c = new FieldContainer!Field();
	foreach (j; 1..3) {
		foreach (i; 1..6) {
			auto f = new Field("FIELD"~to!string(i));
			f.value = to!string(j-1+i*i);
			c ~= f;
		}
	}

	//writeln(c.myRange.take(2));
	c.inspect();

	writeln("\nremove"); c.remove("FIELD5"); c.inspect();
	writeln("\nremove"); c.remove("FIELD5"); c.inspect();
	writeln("\nremove"); c.remove(["FIELD1","FIELD3"]); c.inspect();
	writeln("\nkeep"); c.keep(["FIELD2","FIELD4"]); c.inspect();

	writefln("\nsum: %f", c.sum!float("FIELD2"));
	c.inspect();

}
