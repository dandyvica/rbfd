<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>rbf.fieldcontainer</title>
        </head><body>
        <h1>rbf.fieldcontainer</h1>
        <!-- Generated by Ddoc from source/rbf/fieldcontainer.d -->
<br><br>
<dl><dt><big><a name="FieldContainer"></a>class <u>FieldContainer</u>(T);
</big></dt>
<dd>Generic container for field-like objects<br><br>
<b>Examples:</b><br>
<pre class="d_code">

<font color=blue>import</font> rbf.field;

<font color=blue>auto</font> c = <font color=blue>new</font> <u>FieldContainer</u>!Field();
c ~= <font color=blue>new</font> Field(<font color=red>"FIELD1"</font>, <font color=red>"value1"</font>, <font color=red>"A/N"</font>, 10);
c ~= <font color=blue>new</font> Field(<font color=red>"FIELD2"</font>, <font color=red>"value2"</font>, <font color=red>"A/N"</font>, 30);
c ~= <font color=blue>new</font> Field(<font color=red>"FIELD2"</font>, <font color=red>"value2"</font>, <font color=red>"A/N"</font>, 30);
c ~= <font color=blue>new</font> Field(<font color=red>"FIELD3"</font>, <font color=red>"value3"</font>, <font color=red>"N"</font>, 20);
c ~= <font color=blue>new</font> Field(<font color=red>"FIELD3"</font>, <font color=red>"value3"</font>, <font color=red>"N"</font>, 20);
c ~= <font color=blue>new</font> Field(<font color=red>"FIELD3"</font>, <font color=red>"value3"</font>, <font color=red>"N"</font>, 20);
c ~= <font color=blue>new</font> Field(<font color=red>"FIELD4"</font>, <font color=red>"value4"</font>, <font color=red>"A/N"</font>, 20);

<font color=blue>auto</font> i=1;
<font color=blue>foreach</font> (f; c) {
	f.value = to!string(i++*10);
}

<font color=green>// properties
</font><font color=blue>assert</font>(c.size == 7);
<font color=blue>assert</font>(c.length == 150);
<font color=blue>assert</font>(c.names == [<font color=red>"FIELD1"</font>,<font color=red>"FIELD2"</font>,<font color=red>"FIELD2"</font>,<font color=red>"FIELD3"</font>,<font color=red>"FIELD3"</font>,<font color=red>"FIELD3"</font>,<font color=red>"FIELD4"</font>]);

<font color=green>// opEquals
</font><font color=blue>assert</font>(c == [<font color=red>"FIELD1"</font>,<font color=red>"FIELD2"</font>,<font color=red>"FIELD2"</font>,<font color=red>"FIELD3"</font>,<font color=red>"FIELD3"</font>,<font color=red>"FIELD3"</font>,<font color=red>"FIELD4"</font>]);

<font color=green>// opindex
</font><font color=blue>assert</font>(c[0] == tuple(<font color=red>"FIELD1"</font>,<font color=red>"value1"</font>,<font color=red>"A/N"</font>,10UL));
<font color=blue>assert</font>(c[<font color=red>"FIELD3"</font>].length == 3);
<font color=blue>assert</font>(c[<font color=red>"FIELD3"</font>][1].value!<font color=blue>int</font> == 50);
<font color=blue>assert</font>(c[2..4][1] == tuple(<font color=red>"FIELD3"</font>, <font color=red>"value3"</font>, <font color=red>"N"</font>, 20UL));

<font color=green>// get
</font><font color=blue>assert</font>(c.get(<font color=red>"FIELD3"</font>) == tuple(<font color=red>"FIELD3"</font>, <font color=red>"value3"</font>, <font color=red>"N"</font>, 20UL));

<font color=green>// dispatch
</font><font color=blue>assert</font>(c.FIELD3 == <font color=red>"40"</font>);
<font color=blue>assert</font>(c.FIELD3(1) == <font color=red>"50"</font>);

<font color=green>// arithmetic
</font><font color=blue>assert</font>(c.sum!<font color=blue>int</font>(<font color=red>"FIELD3"</font>) == 150);
<font color=blue>assert</font>(c.min!<font color=blue>int</font>(<font color=red>"FIELD3"</font>) == 40);
<font color=blue>assert</font>(c.max!<font color=blue>int</font>(<font color=red>"FIELD3"</font>) == 60);

<font color=green>// in
</font><font color=blue>assert</font>(<font color=red>"FIELD4"</font> <font color=blue>in</font> c);
<font color=blue>assert</font>(<font color=red>"FIELD10"</font> !<font color=blue>in</font> c);

<font color=green>// misc
</font><font color=blue>assert</font>(c.count(<font color=red>"FIELD3"</font>) == 3);

<font color=green>// range test
</font><font color=blue>static</font> <font color=blue>assert</font>(isBidirectionalRange!(<font color=blue>typeof</font>(c[])));
<font color=green>//c[].each!(e =&gt; assert(e.name.startsWtih("FIELD")));
</font>
<font color=green>// build a new container based on range
</font><font color=blue>auto</font> a = c[].filter!(e =&gt; e.name == <font color=red>"FIELD3"</font>);
<font color=green>//auto d = new FieldContainer!Field(a);
</font></pre>
<br><br>
<dl><dt><big><a name="FieldContainer._list"></a>T[] <u>_list</u>;
</big></dt>
<dd>track all fields within a dynamic array<br><br>

</dd>
<dt><big><a name="FieldContainer._map"></a>T[][TNAME] <u>_map</u>;
</big></dt>
<dd>and as several instance of the same field can exist,<br><br>

</dd>
<dt><big><a name="FieldContainer._length"></a>TLENGTH <u>_length</u>;
</big></dt>
<dd>need to keep track of all instances
<br><br>
current length of the container when adding elements<br><br>

</dd>
<dt><big><a name="FieldContainer.this"></a>this(ushort <i>preAllocSize</i> = PRE_ALLOC_SIZE);
</big></dt>
<dd>Constructor taking an optional parameter
<br><br>
<b>Params:</b><br>
<table><tr><td>ushort <i>preAllocSize</i></td>
<td>preallocation of the inner array</td></tr>
</table><br>

</dd>
<dt><big><a name="FieldContainer.this.2"></a>this(Range <i>r</i>);
</big></dt>
<dd>Constructor taking an input range
<br><br>
<b>Params:</b><br>
<table><tr><td>Range <i>r</i></td>
<td>range</td></tr>
</table><br>

</dd>
<dt><big><a name="FieldContainer.opSlice"></a>Range <u>opSlice</u>();
</big></dt>
<dd>Return a range on the container<br><br>

</dd>
<dt><big><a name="FieldContainer.size"></a>@property ulong <u>size</u>();
</big></dt>
<dd>Get container number of elements<br><br>

</dd>
<dt><big><a name="FieldContainer.length"></a>@property ulong <u>length</u>();
</big></dt>
<dd>get <u>length</u> of all elements<br><br>

</dd>
<dt><big><a name="FieldContainer.names"></a>TNAME[] <u>names</u>();
</big></dt>
<dd>Return all elements <u>names</u><br><br>

</dd>
<dt><big><a name="FieldContainer.opOpAssign"></a>void <u>opOpAssign</u>(string op)(T <i>element</i>) if (op == "~");
</big></dt>
<dd>append a new <i>element</i><br><br>

</dd>
<dt><big><a name="FieldContainer.opIndex"></a>T <u>opIndex</u>(size_t <i>i</i>);
</big></dt>
<dd>[] operator to retrieve <i>i</i>-th element
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>i</i></td>
<td>index of the <i>i</i>-th element to retrieve</td></tr>
</table><br>
<b>Returns:</b><br>
An element of type T<br><br>

</dd>
<dt><big><a name="FieldContainer.opIndex.2"></a>T[] <u>opIndex</u>(TNAME <i>name</i>);
</big></dt>
<dd>[] operator to retrieve field object whose <i>name</i> is passed as an argument
<br><br>
<b>Params:</b><br>
<table><tr><td>TNAME <i>name</i></td>
<td><i>name</i> of the element to retrieve</td></tr>
</table><br>
<b>Returns:</b><br>
An array of elements of type T<br><br>

</dd>
<dt><big><a name="FieldContainer.opSlice.2"></a>T[] <u>opSlice</u>(size_t <i>i</i>, size_t <i>j</i>);
</big></dt>
<dd>Slicing operating
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>i</i></td>
<td>lower index</td></tr>
<tr><td>size_t <i>j</i></td>
<td>upper index</td></tr>
</table><br>
<b>Returns:</b><br>
An array of elements of type T<br><br>

</dd>
<dt><big><a name="FieldContainer.get"></a>T <u>get</u>(TNAME <i>name</i>, ushort <i>index</i> = 0);
</big></dt>
<dd><u>get</u> the i-th field whose is passed as argument in case of duplicate
 field names (starting from 0)
<br><br>
<b>Returns:</b><br>
An array of elements of type T<br><br>

</dd>
<dt><big><a name="FieldContainer.opDispatch"></a>@property TVALUE <u>opDispatch</u>(TNAME name)();
</big></dt>
<dd>Get the value of element
<br><br>
<b>Params:</b><br>
<table><tr><td>name</td>
<td>name of the element to retrieve</td></tr>
</table><br>
<b>Returns:</b><br>
value of the first element found<br><br>

</dd>
<dt><big><a name="FieldContainer.opDispatch.2"></a>TVALUE <u>opDispatch</u>(TNAME name)(ushort <i>index</i>);
</big></dt>
<dd>to match an element more easily<br><br>

</dd>
<dt><big><a name="FieldContainer.remove"></a>void <u>remove</u>(TNAME <i>name</i>);
</big></dt>
<dd><u>remove</u> all elements matching <i>name</i> (as the same <i>name</i> may appear several times)
<br><br>
<b>Params:</b><br>
<table><tr><td>TNAME <i>name</i></td>
<td><i>name</i> of the elements to <u>remove</u></td></tr>
</table><br>

</dd>
<dt><big><a name="FieldContainer.remove.2"></a>void <u>remove</u>(TNAME[] <i>name</i>);
</big></dt>
<dd><u>remove</u> all elements in the list<br><br>

</dd>
<dt><big><a name="FieldContainer.keepOnly"></a>void <u>keepOnly</u>(TNAME[] <i>name</i>);
</big></dt>
<dd>remove all elements not in the list<br><br>

</dd>
<dt><big><a name="FieldContainer.sum"></a>U <u>sum</u>(U)(TNAME <i>name</i>);
</big></dt>
<dd>Returns the <u>sum</u> of elements converted to type U<br><br>

</dd>
<dt><big><a name="FieldContainer.max"></a>U <u>max</u>(U)(TNAME <i>name</i>);
</big></dt>
<dd>get the maximum of all elements converted to type U<br><br>

</dd>
<dt><big><a name="FieldContainer.min"></a>U <u>min</u>(U)(TNAME <i>name</i>);
</big></dt>
<dd>get the minimum of all elements converted to type U<br><br>

</dd>
<dt><big><a name="FieldContainer.opBinaryRight"></a>T[]* <u>opBinaryRight</u>(string op)(TNAME <i>name</i>);
</big></dt>
<dd>iter<br><br>

</dd>
<dt><big><a name="FieldContainer.count"></a>auto <u>count</u>(TNAME <i>name</i>);
</big></dt>
<dd><u>count</u> number of elements having the same <i>name</i><br><br>

</dd>
<dt><big><a name="FieldContainer.opEquals"></a>bool <u>opEquals</u>(TNAME[] <i>list</i>);
</big></dt>
<dd>test if all elements match names<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
